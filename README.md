# Ð‘Ñ€Ð°Ð¶Ð½Ð¸ÐºÐ¾Ð² Ð˜Ð»ÑŒÑ ÐÐ½Ð´Ñ€ÐµÐµÐ²Ð¸Ñ‡ (22 Ð³Ð¾Ð´Ð°)

## ÐžÐ±Ñ€Ð°Ð·Ð¾Ð²Ð°Ð½Ð¸Ðµ ðŸ‘¨â€ðŸŽ“:
- Ð¨ÐºÐ¾Ð»Ð° 2006-2015
- Ð­Ð»ÐµÐºÑ‚Ñ€Ð¾Ñ‚ÐµÑ…Ð½Ð¸Ñ‡ÐµÑÐºÐ¸Ð¹ ÐºÐ¾Ð»Ð»ÐµÐ´Ð¶ (Ñ€Ð°Ð·Ñ€Ð°Ð±Ð¾Ñ‚ÐºÐ° ÐŸÐž) 2015-2019
- Ð—Ð°Ð¿Ð¾Ñ€Ð¾Ð¶ÑÐºÐ¸Ð¹ ÐÐ°Ñ†Ð¸Ð¾Ð½Ð°Ð»ÑŒÐ½Ñ‹Ð¹ Ð¢ÐµÑ…Ð½Ð¸Ñ‡ÐµÑÐºÐ¸Ð¹ Ð£Ð½Ð¸Ð²ÐµÑ€ÑÐ¸Ñ‚ÐµÑ‚ (Ð˜Ð½Ð¶ÐµÐ½ÐµÑ€Ð¸Ñ ÐŸÐž) 2019-2022

## ÐžÐ¿Ñ‹Ñ‚ Ñ€Ð°Ð±Ð¾Ñ‚Ñ‹ ðŸ’¼:
- **SolidSolution** (Full Stack Developer) Ð¸ÑŽÐ½ÑŒ 2018 - Ð¾ÐºÑ‚ÑÐ±Ñ€ÑŒ 2018
- **DevIT** - (Full Stack Developer) Ð¾ÐºÑ‚ÑÐ±Ñ€ÑŒ 2018 - Ð°Ð¿Ñ€ÐµÐ»ÑŒ 2021
- **Mine Finance Group** - (Full Stack Developer) Ð°Ð¿Ñ€ÐµÐ»ÑŒ 2021 - Ð½Ð°ÑÑ‚Ð¾ÑÑ‰ÐµÐµ Ð²Ñ€ÐµÐ¼Ñ

## Ð˜Ð½ÑÑ‚Ñ€ÑƒÐ¼ÐµÐ½Ñ‚Ñ‹ ðŸ› :

### BackEnd:
- PHP 5.6 (6 Ð¼ÐµÑÑÑ†ÐµÐ²)
- PHP 7.x (3 Ð³Ð¾Ð´Ð°)
- Laravel (3 Ð³Ð¾Ð´Ð°)
- WordPress (6 Ð¼ÐµÑÑÑ†ÐµÐ²)
- Drupal 7 (6 Ð¼ÐµÑÑÑ†ÐµÐ²)
- Express (2 Ð¼ÐµÑÑÑ†Ð°)
- MySQL
- Redis
- Docker

### FrontEnd:
- EsmaScript5+ (3 Ð³Ð¾Ð´Ð°)
- React (1 Ð³Ð¾Ð´)
- Angular (3 Ð¼ÐµÑÑÑ†Ð°)
- Vue (6 Ð¼ÐµÑÑÑ†ÐµÐ²)
- jQuery (3 Ð³Ð¾Ð´Ð°)
- TypeScript (1 Ð³Ð¾Ð´)
- webpack
- gulp

### ÐžÐ±Ñ‰ÐµÐµ:
- GIT
- Docker
- Linux (Debian-Ð¿Ð¾Ð´Ð¾Ð±Ð½Ñ‹Ðµ)
- Swagger
- Postman

## Ð Ð°Ð±Ð¾Ñ‚Ð° Ñ API â˜ï¸:
- AWS
- Google (maps, firebase)
- ÐŸÐ»Ð°Ñ‚ÐµÐ¶Ð½Ñ‹Ðµ ÑÐ¸ÑÑ‚ÐµÐ¼Ñ‹

## Ð¯Ð·Ñ‹ÐºÐ¸ ðŸ:
- Ð ÑƒÑÑÐºÐ¸Ð¹ (Ð½Ð¾ÑÐ¸Ñ‚ÐµÐ»ÑŒ)
- Ð£ÐºÑ€Ð°Ð¸Ð½ÑÐºÐ¸Ð¹ (Ð½Ð¾ÑÐ¸Ñ‚ÐµÐ»ÑŒ)
- ÐÐ½Ð³Ð»Ð¸Ð¹ÑÐºÐ¸Ð¹ (Ð±Ð°Ð·Ð¾Ð²Ñ‹Ð¹ Ñ€Ð°Ð·Ð³Ð¾Ð²Ð¾Ñ€Ð½Ñ‹Ð¹, Ñ‡Ñ‚ÐµÐ½Ð¸Ðµ/Ð½Ð°Ð¿Ð¸ÑÐ°Ð½Ð¸Ðµ Ð´Ð¾ÐºÑƒÐ¼ÐµÐ½Ñ‚Ð°Ñ†Ð¸Ð¸)

## Ð”Ð¾Ð¿Ð¾Ð»Ð½Ð¸Ñ‚ÐµÐ»ÑŒÐ½Ð°Ñ Ð¸Ð½Ñ„Ð¾Ñ€Ð¼Ð°Ñ†Ð¸Ñ ðŸ—’:
- Ð¾Ñ‚Ð²ÐµÑ‚ÑÑ‚Ð²ÐµÐ½Ð½Ñ‹Ð¹
- ÐºÑ€ÐµÐ°Ñ‚Ð¸Ð²Ð½Ñ‹Ð¹
- ÐºÐ¾Ð¼Ð¼ÑƒÐ½Ð¸ÐºÐ°Ð±ÐµÐ»ÑŒÐ½Ñ‹Ð¹
- Ð²Ð½Ð¸Ð¼Ð°Ñ‚ÐµÐ»ÑŒÐ½Ñ‹Ð¹ Ðº Ð´ÐµÑ‚Ð°Ð»ÑÐ¼
- Ð¾Ñ‚ÐºÑ€Ñ‹Ñ‚ Ðº Ð½Ð¾Ð²Ñ‹Ð¼ Ð·Ð½Ð°Ð½Ð¸ÑÐ¼ Ð¸ Ð½Ð°Ð²Ñ‹ÐºÐ°Ð¼
- Ð½Ð°Ð»Ð¸Ñ‡Ð¸Ðµ Ð»Ð¸Ð´ÐµÑ€ÑÐºÐ¸Ñ… Ð¸ ÑƒÐ¿Ñ€Ð°Ð²Ð»ÐµÐ½Ñ‡ÐµÑÐºÐ¸Ñ… Ð½Ð°Ð²Ñ‹ÐºÐ¾Ð²

## ÐŸÑ€Ð¸Ð¼ÐµÑ€Ñ‹ ÐºÐ¾Ð´Ð° âŒ¨ï¸:

### TypeScript:
```TypeScript
type ObserverCallback = (time: number) => void  
  
type ObserverSubscriber = {  
  period: number;  
  nextCall: number;  
  callback: ObserverCallback;  
  alias: string;  
}  
  
class Observer {  
  private subscribers: ObserverSubscriber[] = [];  
  
 private timeout?: number;  
  
 constructor () {  
    this.setTimeout()  
  }  
  
  public subscribe (callback: ObserverCallback, alias: string, period: number = 1): void {  
    period = Math.round(period)  
  
    if (period < 1) {  
      console.error('Observer: Period must be grates than 1')  
      return  
  }  
  
    this.subscribers.push({  
      period,  
  alias,  
  callback,  
  nextCall: Observer.getCurrentTimestampInSeconds() + period  
    })  
  }  
  
  public unsubscribe (alias: string): void {  
    this.subscribers = this.subscribers.filter((subscriber) => subscriber.alias !== alias)  
  }  
  
  public exists (alias: string): boolean {  
    return this.subscribers.some((subscriber) => subscriber.alias === alias)  
  }  
  
  private setTimeout () {  
    this.timeout = setTimeout(() => {  
      const timestamp = Observer.getCurrentTimestampInSeconds()  
      this.subscribers.forEach((subscriber: ObserverSubscriber) => {  
        if (subscriber.nextCall <= timestamp) {  
          subscriber.callback(timestamp)  
          subscriber.nextCall = timestamp + subscriber.period  
  }  
      })  
  
      this.setTimeout()  
    }, 1000)  
  }  
  
  private static getCurrentTimestampInSeconds (): number {  
    return Math.round(new Date().getTime() / 1000)  
  }  
}  
  
const observer = new Observer()  
  
export default observer
```

### Vue:
```html
<template>
  <slot v-if="!needActiveLocationPermission" />
  <div class="location-error-wrapper" v-if="needActiveLocationPermission">
    <Card classes="location-error">
      <template v-slot:title>
        {{ translate('title') }}
      </template>
      <p>{{ translate('description') }}</p>
      <div class="location-actions">
        <MainButton :text="translate('check_again')" classes="check-again" @click="getLocation" />
      </div>
    </Card>
  </div>
</template>

<script lang="ts">
import { Options } from 'vue-class-component'
import { createMapper } from 'vuex-smart-module'

import observer from '@/libraries/observer'
import { LOCATION_OBSERVER_NAME } from '@/constants'

import { Position } from '@/types/libraries/Position'
import { WorkShiftType } from '@/types/entities/WorkShiftType'

import TranslatableClassComponent from '@/components/abstaract/TranslatableClassComponent'

import Card from '@/components/base/cards/Card.vue'
import MainButton from '@/components/base/buttons/MainButton.vue'

import Auth from '@/store/Auth'
import Config from '@/store/Config'
import Location from '@/store/Location'
import WorkShift from '@/store/WorkShift'

@Options({
  data () {
    return {
      gotPatrolAreas: false,
      positionWatcher: undefined
    }
  },
  components: {
    MainButton,
    Card
  },
  methods: {
    ...createMapper(Location).mapActions({
      getLocation: 'getLocation',
      getPatrolAreas: 'getPatrolAreas',
      setLocation: 'setLocation'
    }),
    ...createMapper(Location).mapMutations({
      setNeedActiveLocationPermission: 'setNeedActiveLocationPermission'
    }),
    subscribeToLocation () {
      observer.subscribe(this.setLocationIfNeeded, LOCATION_OBSERVER_NAME, this.updateCoordinatesPeriod)
      this.positionWatcher = navigator.geolocation.watchPosition(this.updateLocation, (error) => {
        if (error.code === 1) {
          this.setNeedActiveLocationPermission(true)
        }
      })
    },
    unsubscribeFromLocation () {
      observer.unsubscribe(LOCATION_OBSERVER_NAME)
      navigator.geolocation.clearWatch(this.positionWatcher)
    }
  },
  computed: {
    ...createMapper(Auth).mapGetters({
      isAuth: 'isAuth'
    }),
    ...createMapper(Location).mapGetters({
      needActiveLocationPermission: 'needActiveLocationPermission'
    }),
    ...createMapper(Config).mapGetters({
      updateCoordinatesPeriod: 'updateCoordinatesPeriod',
      showMap: 'showMap'
    }),
    ...createMapper(WorkShift).mapGetters({
      workShift: 'workShift'
    })
  },
  created () {
    if (!this.workShift) {
      return
    }

    this.subscribeToLocation()

    if (this.showMap) {
      this.getPatrolAreas()
      this.gotPatrolAreas = true
    }
  },
  watch: {
    workShift (nextWorkShift?: WorkShiftType, prevWorkShift?: WorkShiftType) {
      if (nextWorkShift && !prevWorkShift) {
        this.subscribeToLocation()

        if (this.showMap) {
          this.getPatrolAreas()
          this.gotPatrolAreas = true
        }
      }

      if (!nextWorkShift && prevWorkShift) {
        this.unsubscribeFromLocation()
      }
    },
    showMap (showMap: boolean) {
      if (showMap && !this.gotPatrolAreas) {
        this.getPatrolAreas()
        this.gotPatrolAreas = true
      }
    }
  }
})

export default class ConfigProvider extends TranslatableClassComponent {
  translationGroup = 'squad_location_detect_error_screen';

  currentPosition?: Position;
  lastSentPosition?: Position;

  setLocation!: (position: Position) => Promise<Position>;

  updateLocation (geoLocationPosition: GeolocationPosition) {
    this.currentPosition = {
      lat: geoLocationPosition.coords.latitude,
      lng: geoLocationPosition.coords.longitude,
      accuracy: geoLocationPosition.coords.accuracy
    }
  }

  setLocationIfNeeded () {
    const position = this.currentPosition
    if (!position || JSON.stringify(position) === JSON.stringify(this.lastSentPosition)) {
      return
    }

    this.setLocation(position).then(() => {
      this.lastSentPosition = position
    })
  }
}
</script>

<style lang="scss">
.location-error-wrapper {
  display: flex;
  justify-content: center;
  align-items: center;
  height: 100%;
  width: 100%;

  .location-error {
    margin: 20px;

    .location-actions {
      width: 100%;
      text-align: center;
    }
  }
}
</style>

```

### Laravel:
```php
<?php

namespace App\Traits\Model;

use App\Storages\GeoStorage;
use Illuminate\Support\Arr;

trait RedisBaseTrait
{
    private ?array $redisBase = null;

    private bool $redisFetched = false;
    private bool $redisChanged = false;
    private bool $saveChangedRedisBase = true;

    public static function deleteBaseDataFromRedisById(int $id): void
    {
        static::getGeoStorage()->deleteByKey(static::getRedisKeyById($id));
    }

    public function getRedisBaseAttribute(): array
    {
        if ($this->redisFetched) {
            return $this->redisBase;
        }

        if (empty($this->id)) {
            $this->redisBase = [];
        } else {
            $this->redisBase = static::getGeoStorage()->getByKey(static::getRedisKeyById($this->id)) ?? [];
        }

        $this->redisFetched = true;

        return $this->redisBase;
    }

    public function setRedisBaseAttribute(array $redisBase): void
    {
        $this->redisBase = $redisBase;

        $this->redisFetched = true;
        $this->redisChanged = true;
    }

    public function updateRedisData(string $key, $value): void
    {
        if (!$this->redisFetched) {
            $this->getRedisBaseAttribute();
        }

        Arr::set($this->redisBase, $key, $value);
        $this->redisChanged = true;
    }

    public function clearRedisBase():void
    {
        $this->redisBase = null;
        $this->redisChanged = false;
        $this->redisFetched = false;
    }

    public function saveAndClearRedisBase(): void
    {
        if (!$this->redisChanged || !$this->saveChangedRedisBase || empty($this->id)) {
            return;
        }

        static::getGeoStorage()->setByKey(static::getRedisKeyById($this->id), $this->redisBase);

        $this->clearRedisBase();
    }

    public function deleteBaseDataFromRedis(): void
    {
        if (empty($this->id)) {
            return;
        }

        $this->saveChangedRedisBase = false;
        static::deleteBaseDataFromRedisById($this->id);
    }

    public function __destruct()
    {
        $this->saveAndClearRedisBase();
    }

    private static function getGeoStorage(): GeoStorage
    {
        return app()->make(GeoStorage::class);
    }

    private static function getRedisKeyById(int $id): string
    {
        return static::$redisKeyPrefix . "{$id}";
    }
}

```
